# EMQX JWT 认证配置

node {
  # 使用容器名保持单节点部署时的节点标识一致
  name = "emqx@mqtt-broker-emqx"
  cookie = "emqx_cookie_xa7s92p"
  data_dir = "/opt/emqx/data"
}

# 单机部署：关闭静态集群发现，避免连接不存在的节点
cluster {
  name = emqxcl
  discovery_strategy = manual
}

# 认证链：先检查超级用户（AI服务），再检查JWT（设备）
authentication = [
  # 1. 超级用户认证（AI服务使用）
  {
    mechanism = password_based
    backend = built_in_database
    enable = true
    user_id_type = username
  },
  
  # 2. JWT 认证（设备使用）
  {
    mechanism = jwt
    enable = true
    
    # 使用 HMAC 算法（与后端 auth.AuthToken 一致）
    use_jwks = false
    algorithm = hmac-based
    secret = "abc"  # 与 config.yaml 中的 server.token 一致
    secret_base64_encoded = false
    
    # 从 username 字段验证
    verify_claims {
      username = "${username}"
    }
    
    # JWT 位置：password 字段
    from = password
    
    # 启用JWT中的ACL规则
    acl_claim_name = "acl"
  }
]

# 授权配置：超级用户使用内置数据库，设备使用JWT中的ACL规则
authorization {
  no_match = deny
  deny_action = disconnect
  
  sources = [
    # 内置数据库授权（超级用户拥有所有权限）
    {
      type = built_in_database
      enable = true
    }
    
    # 注意：设备的ACL规则已经在JWT Token中，EMQX会自动应用
    # 不再需要HTTP ACL接口，提升性能
  ]
}

# Dashboard 配置
dashboard {
  listeners.http {
    bind = "0.0.0.0:18083"
  }
  default_username = "admin"
  default_password = "public"
}

# MQTT 监听器
listeners.tcp.default {
  bind = "0.0.0.0:1883"
  max_connections = 1024000
}

listeners.ws.default {
  bind = "0.0.0.0:8083"
  max_connections = 1024000
  websocket.mqtt_path = "/mqtt"
}
